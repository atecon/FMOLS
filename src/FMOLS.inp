function matrix timepoly (scalar T,
                          scalar maxpower)
    /* */

    hT = floor(T / 2)
    even = T % 2
    ret = ones(T, 1)

    if maxpower > 0
        trend = seq((1 - even - hT), hT)'
        # trend = seq(1, self.T)'
        ret ~= trend .^ seq(1, maxpower)
    endif

    return ret
end function

function void print_results (scalar t,
                             string regnames,
                             matrix b1m,
                             matrix b2m,
                             int k1,
                             int k2,
                             int whiten,
                             int kernel_id,
                             int band,
                             scalar eband)
    string detnames = k1 ? "constant,trend" : "constant"
    print  "======================================================================"
    printf "Fully Modified Least Squares Regression (sample size = %d)\n", t
    print  "_____________________________________________________________________"
    print  ""
    print  "  I(1) variables"
    modprint b1m regnames
    print ""
    print "Deterministic terms"
    modprint b2m detnames
    print ""
    printf "Assumed regressor deterministics:"
    if k2 == 0
        printf " Constant\n"
    elif k2 == 1
        printf " Constant and trend\n"
    elif k2 == 2
        printf " Constant, linear and quadratic trend\n"
    endif
    printf "Method of Estimation of Covariance Parameters:"
    if whiten
        printf " Pre-Whitened\n"
    else
        printf " Not Pre-Whitened\n"
    endif
    printf "Kernel:"
    if kernel_id == 1
        printf " Quadratic Spectral\n"
    elif kernel_id == 2
        printf " Parzen\n"
    elif kernel_id == 3
        printf " Bartlett\n"
    endif
    printf "Bandwidth:"
    if band == 0
        printf " Automatic, estimate = %5.3g\n", eband
    elif band < 0
        printf " Preset at 0\n"
    else
        printf " Preset at = %5.3g\n", eband
    endif
    print  "======================================================================"
    printf "\n\n"
end function

function scalar bwidth (int kernel_id,
                        int T,
                        const matrix ae,
                        const matrix se,
                        const scalar ad)
    if kernel_id == 1 # Quadratic Spectral
        scalar coeff_white = 4*(sumc((ae.*se./((1-ae).^4)).^2))/ad
        eband = 1.3221*((coeff_white*T)^.2)
    elif kernel_id == 2 # Parzen
        scalar coeff_white = 4*(sumc((ae.*se./((1-ae).^4)).^2))/ad
        eband = 2.6614*((coeff_white*T)^.2)
    elif kernel_id == 3 # Bartlett
        scalar coeff_white = 4*(sumc((ae.*se./(((1-ae).^3).*(1+ae))).^2))'/ad
        eband = 1.1447*((coeff_white*T)^(1/3))
    else
        eband = NA
    endif
    return eband
end function


function matrix compute_kernel (const int T,
                                int kernel_id,
                                scalar eband)
    /* */
    matrix kernel_est = {}
    matrix jb = seq(1, (T-1)) ./ eband

    if kernel_id == 1   # Quadratic Spectral Kernel #
        jband = jb * 1.2 * $pi
        kernel_est = 3 * ((sin(jband)./jband - cos(jband))./(jband.^2))
    elif kernel_id == 2     #  Parzen kernel_id
        kernel_est = (1 - (jb.^2)*6 + (jb.^3)*6).*(jb .<= 0.5)
        kernel_est = kernel_est + 2 * ((1-jb).^3) .* ((jb .<=1) && (jb .> 0.5))
    elif kernel_id == 3     #  Bartlett kernel_id
        kernel_est = (1-jb).*(jb .<= 1)
    endif

    return vec(kernel_est)
end function


function bundle check_sample (const list L)
    /*  */

    scalar Told = $nobs
    smpl L --contiguous
    scalar Tnew = $nobs

    scalar Tdiff = Told - Tnew
    if Tdiff
        Warn(sprintf("Dropped %d observations due to missing values.", Tdiff))
        Info("Sample range: %s to %s", obslabe($t1), obslabe($t2))
    endif

    return _(t1 = $t1, t2 = $t2)
end function


function void add_column_dimensions (bundle *self)
    /*  Determine column dimensions of matrices. */

    scalar self.cols_my = cols(self.my)
    scalar self.cols_mx = cols(self.mx)
    scalar self.cols_mymx = self.cols_my + self.cols_mx
end function


function matrix get_error_dynamics (const list xlist "in levels",
                                    const series deter "Deterministics")
    /* Compute 1st differences and regressor deterministcs on these. */

    matrix uhat
    list sdx = diff(xlist)

    mols({sdx}, {deter}, &uhat)

    return uhat
end function


function series get_bhat_and_error_coint (const series y "Endogenous in levels",
                                          const list xlist "levels + deterministics",
                                          matrix *bhat)
    /* Compute long-run coefficient vector and return residuals which are equivalent to deviations from long-run relationship. */

    catch ols y xlist --quiet
    errorif($error, "Level estimation failed. Abort.")

    matrix bhat = $coeff
    return $uhat
end function


function matrix est_var_model (const matrix m, const int max_lag[1::],
                               matrix *uhat)
    /* Estimate a VAR model by mols(). Return coefficient matrix. */

    scalar init = 1 + max_lag      # get rid of initial NAs
    scalar T = rows(m)
    matrix p = seq(1, max_lag)
    matrix m_lags = mlag(m, p, NA)[init:,]

    matrix bhat = mols( m[init:,], m_lags, &uhat )
    errorif($error, "Prewhitening failed. Abort.")

    return bhat
end function


function scalar compute_bandwidth (const matrix errors,
                                   const int kernel_id)
    /* Compute optimal bandwidth.
    return: scalar value of otpimal bandwidth. */

    scalar T = rows(errors)

    matrix eb = errors[1:(T - 1),]
    matrix ef = errors[2:T,]
    matrix ae = ( sumc(eb .* ef)./sumc(eb.^2) )'
    matrix ee = ef - eb .* ae'
    matrix se = sqrt( meanc(ee.^2) )'
    scalar ad = sumc( (se ./ ((1 - ae).^2)).^2 )'

    return bwidth(kernel_id, T, ae, se, ad)
end function


function bundle FMOLS (series ys,
                       const list xlist,
                       int k1[0:1:0] "Model deterministics" {"Constant", "Constant and Trend"},
                       int k2[0:2:1] "DGP of X" {"No drift in X", "Drift in X", "Quadratic trend in X"},
                       bool whiten[1] "VAR Prewithening for covariance estimation",
                       int kernel_id[1:3:1] "Kernel for covariance estimation" {"Quadratic", "Parzen", "Bartlett"},
                       const bool band[FALSE] "Bandwidth for covariance estimation, default: automatic")
    /* */

    bundle self = null

    self = self + check_sample(deflist(ys, xlist))
    smpl self.t1 self.t2
    self.T = $nobs

    string rnames = varname(xlist)

    # create matrices from input series
    matrix self.my = {ys}
    matrix self.mx = {xlist}

    add_column_dimensions(&self)

    # deterministic order in regressors
    #matrix t2  = timepoly((self.T - 1), xmax(0, (k2 - 1)))

    # As we use series instead of vectors, we don't need to adjust smpl
    series det_levels = timepoly($nobs, k1)
    #smpl (self.t1 + 1) ;            # TODO: why (t1+1) ?
    series det_dynamics  = timepoly($nobs, xmax(0, (k2 - 1)))
    smpl full

    # OLS regression of levels + deterministics
    list X = det_levels xlist
    smpl (self.t1 + 1) ;            # TODO: why (t1+1) ?
    matrix bhat_coint
    #  OLS Residuals and regressor innovations
    series errors_coint = get_bhat_and_error_coint(ys, X, &bhat_coint)
    /*
    # OLS regression of levels + deterministics
    matrix xt = self.mx ~ timepoly(self.T, k1)
    matrix y2 = self.my[2:,]
    matrix {X} = xt[2:,]
    matrix bhat_coint = mols(y2, {X})
    bhat_coint
    */

    # Construct errors of dynamics
    # Note: ols command not applicable as sdx can have multiple columns
    smpl full
    smpl (self.t1 + 1) ;            # TODO: why (t1+1) ?
    matrix errors_dynamic = get_error_dynamics(xlist, det_dynamics)
    /*
    dx = diff(self.mx)[2:,]
    matrix uhat
    # regressor innovation
    mols(dx, {det_dynamics}, &uhat)
    print su2 uhat --range=1:10
    stop
    #*/

    matrix xdx = {X}'errors_dynamic    # Was ist das inhaltlich?

    # Concatenate errors
    matrix errors_stacked = {errors_coint} ~ errors_dynamic
    vcv_errors_stacked = errors_stacked'errors_stacked

    # Pre-whiten residuals using VAR(1)
    if whiten
        matrix errors_white
        scalar PREWHITENING_LAG = 1        # TODO: move to settings
        matrix coeff_white = est_var_model(errors_stacked,\
                                           PREWHITENING_LAG, &errors_white)
        self.Teffective = self.T - 2
    else
        matrix errors_white = errors_stacked
        self.Teffective = self.T - 1
    endif

    # Select Bandwidth
    if band == TRUE
        scalar eband = band
    else
        # TODO: is this alwayw ensured currently?`
        assert(rows(errors_white) == self.Teffective)
        scalar eband = compute_bandwidth(errors_white, kernel_id)
    endif

    * hier weitermachen

    # Estimate Covariances #
    matrix kernel_est = compute_kernel(self.Teffective, kernel_id, eband)
    matrix sigma = errors_white'errors_white

    matrix lam = zeros(self.cols_mymx, self.cols_mymx)
    loop j=1..rows(kernel_est)
        mtmp = errors_white[1:(self.Teffective - j),]'errors_white[(1 + j):self.Teffective,]
        lam += mtmp * kernel_est[j]
    endloop

    delta = sigma + lam
    omega = delta + lam'

    # Recolor
    if whiten
        matrix ai = inv(I(self.cols_mymx) - coeff_white)
        omega = qform(ai', omega)
        delta = ai'delta * ai - ai'(coeff_white'vcv_errors_stacked)
    endif

    # Fully Modified Estimation
    g = mols(omega[2:self.cols_mymx,1],\
            omega[2:self.cols_mymx,2:self.cols_mymx])

    delg = delta[2:self.cols_mymx,1] - \
            delta[2:self.cols_mymx,2:self.cols_mymx] * g

    delg |= zeros((k1 + 1), self.cols_my)
    ystar = y2 - uhat * g
    bhat_coint = xxi * ({X}'ystar - delg)
    b1 = bhat_coint[1:self.cols_mx]
    b2 = bhat_coint[(self.cols_mx +1) :]

    #  Covariance Matrix #
    sg = (omega[1,1] - omega[1,2:self.cols_mymx] * g) / (self.T - 1)
    v = xxi * sg
    errors_stacked = ystar - {X} * bhat_coint
    se = sqrt(diag(v))
    errors_stacked = self.my - xt * bhat_coint

    # I(1) coefficients
    matrix b1m = b1 ~ se[1:self.cols_mx]

    # deterministics
    matrix b2m = b2 ~ se[(self.cols_mx + 1):]

    print_results(self.T, rnames, b1m, b2m, k1, k2, whiten, kernel_id,\
                  band, eband)

    self["b1"] = b1
    self["b2"] = b2
    self["v"] = v
    self["errors_stacked"] = errors_stacked

    return self
end function



function void Debug (const string s)
    printf "\Debug: %s\n", s
end function

function void Info (const string s)
    printf "\nInfo: %s\n", s
end function

function void Warn (const string s)
    printf "\nWarning: %s\n", s
end function

function void Error (const string s)
    printf "\nError: %s\n", s
end function
