function matrix timepoly (scalar T,
                          scalar maxpower)
    /* */

    hT = floor(T / 2)
    even = T % 2
    ret = ones(T, 1)

    if maxpower > 0
        trend = seq((1 - even - hT), hT)'
        # trend = seq(1, self.T)'
        ret ~= trend .^ seq(1, maxpower)
    endif

    return ret
end function

function void print_results (scalar t,
                             string regnames,
                             matrix b1m,
                             matrix b2m,
                             int k1,
                             int k2,
                             int whiten,
                             int kernel_id,
                             int band,
                             scalar eband)
    string detnames = k1 ? "constant,trend" : "constant"
    print  "======================================================================"
    printf "Fully Modified Least Squares Regression (sample size = %d)\n", t
    print  "_____________________________________________________________________"
    print  ""
    print  "  I(1) variables"
    modprint b1m regnames
    print ""
    print "Deterministic terms"
    modprint b2m detnames
    print ""
    printf "Assumed regressor deterministics:"
    if k2 == 0
        printf " Constant\n"
    elif k2 == 1
        printf " Constant and trend\n"
    elif k2 == 2
        printf " Constant, linear and quadratic trend\n"
    endif
    printf "Method of Estimation of Covariance Parameters:"
    if whiten
        printf " Pre-Whitened\n"
    else
        printf " Not Pre-Whitened\n"
    endif
    printf "Kernel:"
    if kernel_id == 1
        printf " Quadratic Spectral\n"
    elif kernel_id == 2
        printf " Parzen\n"
    elif kernel_id == 3
        printf " Bartlett\n"
    endif
    printf "Bandwidth:"
    if band == 0
        printf " Automatic, estimate = %5.3g\n", eband
    elif band < 0
        printf " Preset at 0\n"
    else
        printf " Preset at = %5.3g\n", eband
    endif
    print  "======================================================================"
    printf "\n\n"
end function

function scalar bwidth (int kernel_id,
                        int T,
                        const matrix ae,
                        const matrix se,
                        const scalar ad)
    if kernel_id == 1 # Quadratic Spectral
        scalar coeff_white = 4*(sumc((ae.*se./((1-ae).^4)).^2))/ad
        eband = 1.3221*((coeff_white*T)^.2)
    elif kernel_id == 2 # Parzen
        scalar coeff_white = 4*(sumc((ae.*se./((1-ae).^4)).^2))/ad
        eband = 2.6614*((coeff_white*T)^.2)
    elif kernel_id == 3 # Bartlett
        scalar coeff_white = 4*(sumc((ae.*se./(((1-ae).^3).*(1+ae))).^2))'/ad
        eband = 1.1447*((coeff_white*T)^(1/3))
    else
        eband = NA
    endif
    return eband
end function


function matrix compute_kernel (const int T,
                                int kernel_id,
                                scalar eband)
    /* */
    matrix kernel_est = {}
    matrix jb = seq(1, (T-1)) ./ eband

    if kernel_id == 1   # Quadratic Spectral Kernel #
        jband = jb * 1.2 * $pi
        kernel_est = 3 * ((sin(jband)./jband - cos(jband))./(jband.^2))
    elif kernel_id == 2     #  Parzen kernel_id
        kernel_est = (1 - (jb.^2)*6 + (jb.^3)*6).*(jb .<= 0.5)
        kernel_est = kernel_est + 2 * ((1-jb).^3) .* ((jb .<=1) && (jb .> 0.5))
    elif kernel_id == 3     #  Bartlett kernel_id
        kernel_est = (1-jb).*(jb .<= 1)
    endif

    return vec(kernel_est)
end function


function bundle check_sample (const list L)
    /*  */

    scalar Told = $nobs
    smpl L --contiguous
    scalar Tnew = $nobs

    scalar Tdiff = Told - Tnew
    if Tdiff
        Warn(sprintf("Dropped %d observations due to missing values.", Tdiff))
        Info("Sample range: %s to %s", obslabe($t1), obslabe($t2))
    endif

    return _(t1 = $t1, t2 = $t2)
end function


function void add_column_dimensions (bundle *self)
    /*  Determine column dimensions of matrices. */

    scalar self.cols_my = cols(self.my)
    scalar self.cols_mx = cols(self.mx)
    scalar self.cols_mymx = self.cols_my + self.cols_mx
end function




function bundle FMOLS (series ys,
                       const list xlist,
                       int k1[0:1:0] "Model deterministics" {"Constant", "Constant and Trend"},
                       int k2[0:2:1] "DGP of X" {"No drift in X", "Drift in X", "Quadratic trend in X"},
                       bool whiten[1] "VAR Prewithening for covariance estimation",
                       int kernel_id[1:3:1] "Kernel for covariance estimation" {"Quadratic", "Parzen", "Bartlett"},
                       scalar band[0] "Bandwidth for covariance estimation, default: automatic")
    /* */

    bundle self = null

    self = self + check_sample(deflist(ys, xlist))
    smpl self.t1 self.t2
    self.T = $nobs

    string rnames = varname(xlist)

    # create matrices from input series
    matrix self.my = {ys}
    matrix self.mx = {xlist}

    add_column_dimensions(&self)

    # deterministic order in regressors
    #matrix t2  = timepoly((self.T - 1), xmax(0, (k2 - 1)))

    # As we use series instead of vectors, we don't need to adjust smpl
    series det_levels = timepoly($nobs, k1)
    #smpl (self.t1 + 1) ;            # TODO: why (t1+1) ?
    series det_dynamics  = timepoly($nobs, xmax(0, (k2 - 1)))
    smpl full

    # OLS regression of levels + deterministics
    list X = det_levels xlist
    smpl (self.t1 + 1) ;            # TODO: why (t1+1) ?
    ols ys X --quiet
    matrix bhat_coint = $coeff
    #  OLS Residuals and regressor innovations  #
    series errors_coint = $uhat
    /*
    # OLS regression of levels + deterministics
    matrix xt = self.mx ~ timepoly(self.T, k1)
    matrix y2 = self.my[2:,]
    matrix {X} = xt[2:,]
    matrix bhat_coint = mols(y2, {X})
    bhat_coint
    */

    # Construct errors of dynamics
    # Note: ols command not applicable as sdx can have multiple columns
    smpl full
    smpl (self.t1 + 1) ;            # TODO: why (t1+1) ?
    matrix errors_dynamics
    list sdx = diff(xlist)
    mols({sdx}, {det_dynamics}, &errors_dynamics)
    /*
    dx = diff(self.mx)[2:,]
    matrix uhat
    # regressor innovation
    mols(dx, {det_dynamics}, &uhat)
    print su2 uhat --range=1:10
    stop
    #*/

    matrix xdx = {X}'errors_dynamics    # Was ist das inhaltlich?

    # Concatenate errors
    matrix errors_stacked = {errors_coint} ~ errors_dynamics
    vcv_errors_stacked = errors_stacked'errors_stacked

    # Pre-whiten residuals using VAR(1)
    if whiten
        matrix errors_white
        errors_stacked_1 = mlag(errors_stacked, 1, NA)[2:,]
        matrix coeff_white = mols(errors_stacked[2:(self.T - 1),],\
                                  errors_stacked_1, &errors_white)

        self.Teffective = self.T - 2
    else
        matrix errors_white = errors_stacked
        self.Teffective = self.T - 1
    endif

    # Select Bandwidth
    if band == 0
        matrix eb = errors_white[1:(self.Teffective - 1),]
        matrix ef = errors_white[2:self.Teffective,]
        matrix ae = (sumc(eb .* ef)./sumc(eb.^2))'
        matrix ee = ef - eb .* ae'
        matrix se = sqrt(meanc(ee.^2))'
        scalar ad = sumc((se ./ ((1 - ae).^2)).^2)'
        scalar eband = bwidth(kernel_id, self.Teffective, ae, se, ad)
    else
        scalar eband = band
    endif

    # Estimate Covariances #
    matrix kernel_est = compute_kernel(self.Teffective, kernel_id, eband)
    matrix sigma = errors_white'errors_white

    matrix lam = zeros(self.cols_mymx, self.cols_mymx)
    loop j=1..rows(kernel_est)
        mtmp = errors_white[1:(self.Teffective - j),]'errors_white[(1 + j):self.Teffective,]
        lam += mtmp * kernel_est[j]
    endloop

    delta = sigma + lam
    omega = delta + lam'

    # Recolor
    if whiten
        matrix ai = inv(I(self.cols_mymx) - coeff_white)
        omega = qform(ai', omega)
        delta = ai'delta * ai - ai'(coeff_white'vcv_errors_stacked)
    endif

    # Fully Modified Estimation
    g = mols(omega[2:self.cols_mymx,1],\
            omega[2:self.cols_mymx,2:self.cols_mymx])

    delg = delta[2:self.cols_mymx,1] - \
            delta[2:self.cols_mymx,2:self.cols_mymx] * g

    delg |= zeros((k1 + 1), self.cols_my)
    ystar = y2 - uhat * g
    bhat_coint = xxi * ({X}'ystar - delg)
    b1 = bhat_coint[1:self.cols_mx]
    b2 = bhat_coint[(self.cols_mx +1) :]

    #  Covariance Matrix #
    sg = (omega[1,1] - omega[1,2:self.cols_mymx] * g) / (self.T - 1)
    v = xxi * sg
    errors_stacked = ystar - {X} * bhat_coint
    se = sqrt(diag(v))
    errors_stacked = self.my - xt * bhat_coint

    # I(1) coefficients
    matrix b1m = b1 ~ se[1:self.cols_mx]

    # deterministics
    matrix b2m = b2 ~ se[(self.cols_mx + 1):]

    print_results(self.T, rnames, b1m, b2m, k1, k2, whiten, kernel_id,\
                  band, eband)

    self["b1"] = b1
    self["b2"] = b2
    self["v"] = v
    self["errors_stacked"] = errors_stacked

    return self
end function



function void Debug (const string s)
    printf "\Debug: %s\n", s
end function

function void Info (const string s)
    printf "\nInfo: %s\n", s
end function

function void Warn (const string s)
    printf "\nWarning: %s\n", s
end function

function void Error (const string s)
    printf "\nError: %s\n", s
end function
